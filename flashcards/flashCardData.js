 
	function fc_data() {
		return {
    "1": {
        "title": "Minimum Stack",
        "tag": [
            "115"
        ],
        "hint": "getMin needs to return the minimum of the stack at all times,\neven as values get removed from the stack",
        "note": "push values to both a stack && a minimum stack, keeping track of the minimum at each point in the stack (with a separate stack)\n\nsome other solutions include adding a tuple to your stack, with one value being the new number, and the other value being the minimum at this point\n\nanother solution could also be to keep a minimum stack but only ever updated when we see minimums that are you to or less than the previous minimum\nand when you pop off the value evaluate if you're popping off your current minimum",
        "problem": "Design a stack class that supports the push, pop, top, and getMin operations.\n\n    MinStack() initializes the stack object.\n    void push(int val) pushes the element val onto the stack.\n    void pop() removes the element on the top of the stack.\n    int top() gets the top element of the stack.\n    int getMin() retrieves the minimum element in the stack.\n\nEach function should run in O(1)O(1) time.\n\nInput: [\"MinStack\", \"push\", 1, \"push\", 2, \"push\", 0, \"getMin\", \"pop\", \"top\", \"getMin\"]\n\nOutput: [null,null,null,null,0,null,2,1]\n\nExplanation:\nMinStack minStack = new MinStack();\nminStack.push(1);\nminStack.push(2);\nminStack.push(0);\nminStack.getMin(); // return 0\nminStack.pop();\nminStack.top();    // return 2\nminStack.getMin(); // return 1",
        "code": "class MinStack:\n    def __init__(self):\n        self.stack = []\n        self.minStack = []\n\n    def push(self, val: int) -> None:\n        self.stack.append(val)\n        val = min(val, self.minStack[-1] if self.minStack else val)\n        self.minStack.append(val)\n\n    def pop(self) -> None:\n        self.stack.pop()\n        self.minStack.pop()\n\n    def top(self) -> int:\n        return self.stack[-1]\n\n    def getMin(self) -> int:\n        return self.minStack[-1]"
    },
    "2": {
        "tag": [
            "stack"
        ],
        "title": "Validate Parentheses",
        "note": "only add open characters to the stack, use closed characters to pop the open characters off the stack\nsaid any point that you have a mix matched scenario (\"}\" trying to pop anything but a \"{\"), then we know it's not valid",
        "problem": "You are given a string s consisting of the following characters: '(', ')', '{', '}', '[' and ']'.\n\nThe input string s is valid if and only if:\n\n    Every open bracket is closed by the same type of close bracket.\n    Open brackets are closed in the correct order.\n    Every close bracket has a corresponding open bracket of the same type.\n\nReturn true if s is a valid string, and false otherwise.\n\nExample 1:\n\nInput: s = \"[]\"\n\nOutput: true\n\nExample 2:\n\nInput: s = \"([{}])\"\n\nOutput: true\n\nExample 3:\n\nInput: s = \"[(])\"\n\nOutput: false\n\nExplanation: The brackets are not closed in the correct order.\n\nConstraints:\n\n    1 <= s.length <= 1000",
        "code": "class Solution:\n    def isValid(self, s: str) -> bool:\n        Map = {\")\": \"(\", \"]\": \"[\", \"}\": \"{\"}\n        stack = []\n\n        for c in s:\n            if c not in Map:\n                stack.append(c)\n                continue\n            if not stack or stack[-1] != Map[c]:\n                return False\n            stack.pop()\n\n        return not stack",
        "hint": null
    },
    "3": {
        "tag": [
            "stack"
        ],
        "title": "Evaluate Reverse Polish Notation",
        "note": "you're going to add the first two numbers to the stack, and when you have found there operand, you will pop those values off, evaluate their new value (2 + 1 ---> 3), add their new value to the stack, the next number, the next operand, then pop off those two values and perform that calculation:\nInput: tokens = [\"1\",\"2\",\"+\",\"3\",\"*\",\"4\",\"-\"]\ns = [1, 2] ---> 1 + 2 ---> 3\ns = [3, 3] ---> 3 * 3 ---> 9\ns = [9, 4] ---> 9 - 4 ---> 5",
        "problem": "Evaluate Reverse Polish Notation\n\nYou are given an array of strings tokens that represents a valid arithmetic expression in Reverse Polish Notation.\n\nReturn the integer that represents the evaluation of the expression.\n\n    The operands may be integers or the results of other operations.\n    The operators include '+', '-', '*', and '/'.\n    Assume that division between integers always truncates toward zero.\n\nExample 1:\n(there were only ever be to numbers to evaluate before the operand)\nInput: tokens = [\"1\",\"2\",\"+\",\"3\",\"*\",\"4\",\"-\"]\n\nOutput: 5\n\nExplanation: ((1 + 2) * 3) - 4 = 5\n\nConstraints:\n\n    1 <= tokens.length <= 1000.\n    tokens[i] is \"+\", \"-\", \"*\", or \"/\", or a string representing an integer in the range [-100, 100].",
        "code": "class Solution:\n    def evalRPN(self, tokens: List[str]) -> int:\n        stack = []\n        for c in tokens:\n            if c == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif c == \"-\":\n                a, b = stack.pop(), stack.pop()\n                stack.append(b - a)\n            elif c == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif c == \"/\":\n                a, b = stack.pop(), stack.pop()\n                stack.append(int(float(b) / a))\n            else:\n                stack.append(int(c))\n        return stack[0]",
        "hint": null
    },
    "4": {
        "tag": [
            "stack"
        ],
        "title": "Generate Parentheses",
        "hint": "when forming the string, you will only ever have to decide between two possibilities: adding open parenthesis, adding close parenthesis",
        "note": "use recursion because there'll be two possibilities for most spots: adding open parenthesis, adding close parenthesis\nHowever there are some conditions that will dictate this\nyou won't add a close condition for that spot if you don't already have a valid open parenthesis\nyou won't add in open/close parenthesis if you've exceeded the number of them you can have\nAdd the parentheses to a stack (or string) and when you reached your basecase, which is reaching the valid number of open/close parenthesis, save the result as you have found a valid combination\n\nLesson:\nwhen thinking about forming combinations or forming recursion, always just think about what step you take at any current moment and whatever base cases to tell you to stop",
        "problem": "You are given an integer n. Return all well-formed parentheses strings that you can generate with n pairs of parentheses.\n\nExample 1:\n\nInput: n = 1\n\nOutput: [\"()\"]\n\nExample 2:\n\nInput: n = 3\n\nOutput: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n\nYou may return the answer in any order.\n\nConstraints:\n\n    1 <= n <= 7",
        "code": "class Solution:\n    // n represents the number of pairs of parentheses (3)\n    def generateParenthesis(self, n: int) -> List[str]:\n        stack = []\n        res = []\n\n        def backtrack(open, closed):\n            // when you have an equal number of both you know you've reached a combination\n            if open == closed == n:\n                res.append(\"\".join(stack))\n                return\n\n            // cannot have more than three open parenthesis\n            if open < n:\n                stack.append(\"(\")\n                backtrack(open + 1, closed)\n                stack.pop()\n            \n            // cannot supply a closed parenthesis if one is not already open\n            if closed < open:\n                stack.append(\")\")\n                backtrack(open, closed + 1)\n                stack.pop()\n\n        backtrack(0, 0)\n        \n        return res"
    },
    "5": {
        "tag": [
            "stack"
        ],
        "title": "Daily Temperatures",
        "note": "monotonic decreasing stack\nyou're going to keep track of all of the temperatures as you see them\nwhen you see a number that is greater than the last, pop the last value of the stack\nbecause you found its higher temperature which is what we're looking for.\nkeep popping all of the values that are lesser because that means we satisfied our condition for that day ( we have found a temperature greater )\n\nalong with keeping track of the temperatures each day, will keep track of the index (day) that we last saw it at, and compared to the day/index of this higher value we found\n\ncontinue forward in the list, adding on values that are lesser than or equal to what is already on the stack, and when you find something greater pop all the days off whose conditions are satisfied\n\nif you start off the list full of zeros, any remaining values on the stack that you couldn't find a higher temperature for, will already have zeros in its spot",
        "problem": "You are given an array of integers temperatures where temperatures[i] represents the daily temperatures on the ith day.\n\nReturn an array result where result[i] is the number of days after the ith day before a warmer temperature appears on a future day. If there is no day in the future where a warmer temperature will appear for the ith day, set result[i] to 0 instead.\n\nExample 1:\n\nInput: temperatures = [30,38,30,36,35,40,28]\n\nOutput: [1,4,1,2,1,0,0]\n\nExample 2:\n\nInput: temperatures = [22,21,20]\n\nOutput: [0,0,0]\n\nConstraints:\n\n    1 <= temperatures.length <= 1000.\n    1 <= temperatures[i] <= 100",
        "code": "class Solution:\n    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:\n        res = [0] * len(temperatures)\n        stack = []  # pair: [temp, index]\n\n        for i, t in enumerate(temperatures):\n            while stack and t > stack[-1][0]:\n                stackT, stackInd = stack.pop()\n                res[stackInd] = i - stackInd\n            stack.append((t, i))\n        return res",
        "hint": null
    },
    "6": {
        "tag": [
            "hash"
        ],
        "title": "Duplicate Integer / Contains Duplicates",
        "hint": "hashset",
        "note": "check if in hashset or list",
        "problem": "Given an integer array nums, return true if any value appears more than once in the array, otherwise return false.\n\nExample 1:\n\nInput: nums = [1, 2, 3, 3]\n\nOutput: true\n\nExample 2:\n\nInput: nums = [1, 2, 3, 4]\n\nOutput: false",
        "code": "class Solution:\n    def hasDuplicate(self, nums: List[int]) -> bool:\n        hashset = set()\n\n        for n in nums:\n            if n in hashset:\n                return True\n            hashset.add(n)\n        return False"
    },
    "7": {
        "tag": [
            "hash"
        ],
        "title": "Two Integer Sum",
        "hint": "hashmap",
        "note": "save the difference of the target and sum in the hashmap\nif you find that difference while looping you have found the solution\nmake sure to save this difference with its index as well",
        "problem": "Given an array of integers nums and an integer target, return the indices i and j such that nums[i] + nums[j] == target and i != j.\n\nYou may assume that every input has exactly one pair of indices i and j that satisfy the condition.\n\nReturn the answer with the smaller index first.\n\nExample 1:\n\nInput: \nnums = [3,4,5,6], target = 7\n\nOutput: [0,1]\n\nExplanation: nums[0] + nums[1] == 7, so we return [0, 1].\n\nExample 2:\n\nInput: nums = [4,5,6], target = 10\n\nOutput: [0,2]\n\nExample 3:\n\nInput: nums = [5,5], target = 10\n\nOutput: [0,1]\n\nConstraints:\n\n    2 <= nums.length <= 1000\n    -10,000,000 <= nums[i] <= 10,000,000\n    -10,000,000 <= target <= 10,000,000",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        prevMap = {}  # val -> index\n\n        for i, n in enumerate(nums):\n            diff = target - n\n            if diff in prevMap:\n                return [prevMap[diff], i]\n            prevMap[n] = i"
    },
    "8": {
        "tag": [
            "hash",
            "linked_list"
        ],
        "title": "LRU Cache",
        "hint": "doubly linked list\nclass Node\nclass LRUCache\ndummy notes (LRU, MRU)",
        "note": null,
        "problem": "Implement the Least Recently Used (LRU) cache class LRUCache. The class should support the following operations\n\n    LRUCache(int capacity) Initialize the LRU cache of size capacity.\n    int get(int key) Return the value cooresponding to the key if the key exists, otherwise return -1.\n    void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the introduction of the new pair causes the cache to exceed its capacity, remove the least recently used key.\n\nA key is considered used if a get or a put operation is called on it.\n\nEnsure that get and put each run in O(1)O(1) average time complexity.\n\nExample 1:\n\nInput:\n[\"LRUCache\", [2], \"put\", [1, 10],  \"get\", [1], \"put\", [2, 20], \"put\", [3, 30], \"get\", [2], \"get\", [1]]\n\nOutput:\n[null, null, 10, null, null, 20, -1]\n\nExplanation:\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 10);  // cache: {1=10}\nlRUCache.get(1);      // return 10\nlRUCache.put(2, 20);  // cache: {1=10, 2=20}\nlRUCache.put(3, 30);  // cache: {2=20, 3=30}, key=1 was evicted\nlRUCache.get(2);      // returns 20 \nlRUCache.get(1);      // return -1 (not found)\n\nConstraints:\n\n    1 <= capacity <= 100\n    0 <= key <= 1000\n    0 <= value <= 1000",
        "code": "class Node:\n\tdef __init__(self, key, val):\n\t\tself.key = key\n\t\tself.val = val\n\t\t\n\t\tself.prev = None\n\t\tself.next = None\n\n\nclass LRUCache:\n\tdef __init__(self, capacity: int):\n\t\tself.cap = capacity\n\t\tself.cache = {}  # map key to node\n\n\t\t# these are dummy / unused / label notes\n\t\t# they are used as just the head and end of the linked list, but everything in between are the actual nodes and values\n\t\tself.lru = Node(0, 0)\n\t\tself.mru = Node(0, 0)\n\t\t\n\t\tself.lru.next = self.mru\n\t\t\n\t\tself.mru.prev = self.lru\n\n\tdef remove(self, node):\n\t\t# reassign pointers so that they no longer are pointing at the node\n\t\tprev = node.prev\n\t\t\n\t\tprev.next = node.next\n\t\tnode.next.prev = prev\n\n\tdef insert(self, node):\n\t\t\n\t\tbefore_mru = self.mru.prev\n\t\t\n\t\t# insert new node in between\n\t\tnode.prev = before_mru\n\t\tnode.next = self.mru\n\t\t\n\t\t# reassign pointers so that the new node is seen between\n\t\t# whatever node came before mru, you want their next pointer pointing at node\n\t\tbefore_mru.next = node\n\t\t# then you want mru previous pointer to also be pointing at node\n\t\t# you are essentially placing the node in between those two\n\t\tself.mru.prev = node\n\t\t\n\n\tdef get(self, key: int) -> int:\n\t\tif key in self.cache:\n\t\t\t# remove the node from wherever it is in the list\n\t\t\tself.remove(self.cache[key])\n\t\t\t# and reinsert it towards the MRU side\n\t\t\tself.insert(self.cache[key])\n\t\t\treturn self.cache[key].val\n\t\t\n\t\treturn -1\n\n\tdef put(self, key: int, value: int) -> None:\n\t\tif key in self.cache:\n\t\t\tself.remove(self.cache[key])\n\t\t\n\t\tself.cache[key] = Node(key, value)\n\t\tself.insert(self.cache[key])\n\n\t\tif len(self.cache) > self.cap:\n\t\t\tlru = self.lru.next\n\t\t\tself.remove(lru)\n\t\t\tdel self.cache[lru.key]"
    },
    "9": {
        "tag": [
            "303",
            "prefix_sum"
        ],
        "title": "Range Sum Query - Immutable",
        "hint": "start the prefix_sum with a zero and remember that this problem is asking for inclusive",
        "note": "Lesson: you can use the change in sum overtime to tell you something about to tell you about the sums in the array\n\nnums = [-2, 0, 3, -5, 2, -1]\nprefix_sum = [0, -2, -2, 1, -4, -2, -3]\n(left, right) = (0, 2)\nreturn self.prefix_sum[right+1] - self.prefix_sum[left]\nreturn self.prefix_sum[3] - self.prefix_sum[0]\n\nzero represents the sum before the first element\nan element's index + 1, represents the sum after we have included that number\nbecause the array start of zero everything is shifted right",
        "problem": "Easy\nTopics\nCompanies\n\nGiven an integer array nums, handle multiple queries of the following type:\n\n    Calculate the sum of the elements of nums between indices left and right inclusive where left <= right.\n\nImplement the NumArray class:\n\n    NumArray(int[] nums) Initializes the object with the integer array nums.\n    int sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.e. nums[left] + nums[left + 1] + ... + nums[right]).\n\n \n\nExample 1:\n\nInput\n[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"]\n[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]\nOutput\n[null, 1, -1, -3]\n\nExplanation\nNumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);\nnumArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1\nnumArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1\nnumArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3\n\n \n\nConstraints:\n\n    1 <= nums.length <= 104\n    -105 <= nums[i] <= 105\n    0 <= left <= right < nums.length\n    At most 104 calls will be made to sumRange.",
        "code": "class NumArray:\n\n    def __init__(self, nums):\n        self.prefix_sum = [0] * (len(nums) + 1)\n        for i in range(1, len(nums) + 1):\n            self.prefix_sum[i] = self.prefix_sum[i-1] + nums[i-1]\n        \n        \n\n    def sumRange(self, left: int, right: int) -> int:\n        return self.prefix_sum[right+1] - self.prefix_sum[left]\n        \n\n\nnums = [-2, 0, 3, -5, 2, -1]\n# Your NumArray object will be instantiated and called as such:\nobj = NumArray(nums)\nparam_1 = obj.sumRange(0,2)"
    },
    "10": {
        "tag": [
            "304",
            "prefix_sum"
        ],
        "title": "Range Sum Query 2D - Immutable",
        "hint": "prefix_sum, subtracting values, extra zeros",
        "note": "are basically calculated the sum of the columns across a row, and when you get to the next row, you start adding the sum of the previous row at that column as well\nyou need the extra row and column of zeros just for the calculation at the end. If you're starting coordinates have a zero in them, that means there should be no extra sum accumulated for that corresponding row/col, so we need the extra row of zeros to capture that 0 value\n\nthe idea behind the problem is that a single coordinate in the prefix matrix should be able to tell you the sum up to that point from the (0,0) coordinate diagonally down to that coordinate. in order to capture that entire box of values, you need to know the sum across each row up to a particular point, but also the sum of the previous row on top of that because that basically gives you a box sum\n\nthe graphic below basically explains why you need this subtraction element\n<a href=\"https://docs.google.com/document/d/1s1OLYQGAtEhc9gSdtA933b9T6UnVkuYDKW96jTp7bbg/edit#bookmark=id.4cpkg47hfg6d\" target=\"_blank\">Graphic</a>\n\nLesson: how to save the prefix sum for a matrix, how to delete/discard information correctly",
        "problem": "Range Sum Query 2D - Immutable\n\nGiven a 2D matrix matrix, handle multiple queries of the following type:\n\n    Calculate the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).\n\nImplement the NumMatrix class:\n\n    NumMatrix(int[][] matrix) Initializes the object with the integer matrix matrix.\n    int sumRegion(int row1, int col1, int row2, int col2) Returns the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).\n\nYou must design an algorithm where sumRegion works on O(1) time complexity.\n\n \n\nExample 1:\n\nInput\n[\"NumMatrix\", \"sumRegion\", \"sumRegion\", \"sumRegion\"]\n[[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [1, 1, 2, 2], [1, 2, 2, 4]]\nOutput\n[null, 8, 11, 12]\n\nExplanation\nNumMatrix numMatrix = new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]);\nnumMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e sum of the red rectangle)\nnumMatrix.sumRegion(1, 1, 2, 2); // return 11 (i.e sum of the green rectangle)\nnumMatrix.sumRegion(1, 2, 2, 4); // return 12 (i.e sum of the blue rectangle)\n\n \n\nConstraints:\n\n    m == matrix.length\n    n == matrix[i].length\n    1 <= m, n <= 200\n    -104 <= matrix[i][j] <= 104\n    0 <= row1 <= row2 < m\n    0 <= col1 <= col2 < n\n    At most 104 calls will be made to sumRegion.",
        "code": "def sumRegion(matrix, r1, c1, r2, c2) :\n\tROWS = len(matrix)\n\tCOLS = len(matrix[0])\n\t\n\tprefix_matrix = [[0] * (COLS + 1) for i in range(ROWS + 1)]\n\n\tfor row in range(ROWS):\n\t\trow_prefix = 0\n\t\tfor col in range(COLS):\n\t\t\t# adding up the row of the original matrix\n\t\t\trow_prefix += matrix[row][col]\n\t\t\t# grab the number above in the prefix matrix\n\t\t\tcol_prefix = prefix_matrix[row][col + 1]\n\t\t\t# at the spot equivalent to the matrix, add these two values\n\t\t\t# this type comment will only show accurate results if the coordinate is to the bottom right of the (r1, c1)\n\t\t\t# type: matrix, (r1, c1), (r1, col + 1), (row + 1, c1), (row + 1, col + 1)\n\t\t\tprefix_matrix[row + 1][col + 1] = row_prefix + col_prefix\n\t\n\t\n\t\n\t# (r2 + 1, c2 + 1) - the desired sum (offset because the extra row/col of zeros)\n\t# (r2 + 1, c1) - the sum of the columns that should not be included (c1 causing the cutoff)\n\t# (r1, c2 + 1) - the sum of the rows that should not be included (r1 causing the cutoff)\n\t# (r1, c1) - the sum at starting coordinates that gets removed twice by the above two values, thus needs to be added on once\n\treturn (\n\t\tprefix_matrix[r2 + 1][c2 + 1] - prefix_matrix[r2 + 1][c1] - \n\t\tprefix_matrix[r1][c2 + 1] + prefix_matrix[r1][c1]\n\t)\n\n# type: matrix\nmatrix = [\n\t[3, 0, 1, 4, 2],\n\t[5, 6, 3, 2, 1],\n\t[1, 2, 0, 1, 5],\n\t[4, 1, 0, 1, 7],\n\t[1, 0, 3, 0, 5],\n]"
    },
    "11": {
        "tag": [
            "724",
            "prefix_sum"
        ],
        "title": "Find Pivot Index",
        "hint": "prefix_sum  and postfix_sum, but with zero space, just use two variables",
        "note": "find the sum of the array\nmake two variables representing the sum on either side of an element (lSum, rSum)\none of these variables will be the sum of the array (rSum)\nfor each element in the list, first subtract the current element from the sum so that we can simulate it not being included\n[1,7,3,6,5,6] ---> sum = 28\nif current element = 1, lSum = 0, rSum = 27, (1 is not included)\nevaluate if the two sums are equal, if not, add the current element to the lSum, move onto the next current element (7), and make sure that is not included in the rSum\nif current element = 7, lSum = 1, rSum = 20, (7 is not included)\ncontinue until they are equal. return the index in which they are equal\n<a href=\"https://docs.google.com/document/d/1s1OLYQGAtEhc9gSdtA933b9T6UnVkuYDKW96jTp7bbg/edit#bookmark=id.tbkmvwhjtakr\" target=\"_blank\">Graphic</a>",
        "problem": "Easy\nTopics\nCompanies\nHint\n\nGiven an array of integers nums, calculate the pivot index of this array.\n\nThe pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index's right.\n\nIf the index is on the left edge of the array, then the left sum is 0 because there are no elements to the left. This also applies to the right edge of the array.\n\nReturn the leftmost pivot index. If no such index exists, return -1.\n\n \n\nExample 1:\n\nInput: nums = [1,7,3,6,5,6]\nOutput: 3\nExplanation:\nThe pivot index is 3.\nLeft sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11\nRight sum = nums[4] + nums[5] = 5 + 6 = 11\n\nExample 2:\n\nInput: nums = [1,2,3]\nOutput: -1\nExplanation:\nThere is no index that satisfies the conditions in the problem statement.\n\nExample 3:\n\nInput: nums = [2,1,-1]\nOutput: 0\nExplanation:\nThe pivot index is 0.\nLeft sum = 0 (no elements to the left of index 0)\nRight sum = nums[1] + nums[2] = 1 + -1 = 0\n\n \n\nConstraints:\n\n    1 <= nums.length <= 104\n    -1000 <= nums[i] <= 1000",
        "code": "# Time Complexity : O(n)\n# Space Complexity : O(1)\nclass Solution(object):\n    def pivotIndex(self, nums):\n        \n        leftSum, rightSum = 0, sum(nums)\n        \n        for idx, ele in enumerate(nums):\n            # don't include the current element in the sum\n            rightSum -= ele\n            \n            if leftSum == rightSum:\n                return idx          # Return the pivot index...\n            \n            # include the element after evaluation\n            leftSum += ele\n        return -1                   # If there is no index that satisfies the conditions in the problem statement..."
    },
    "12": {
        "tag": [
            "prefix_sum",
            "238"
        ],
        "title": "Products of Array Discluding Self",
        "hint": "prefix and postfix, only one new array tho",
        "note": "because we want to know the someone either side of the element, we can calculate the pre-and post-fix sums, and just look at those sums, before & after that element (that is not including it)",
        "problem": "Given an integer array nums, return an array output where output[i] is the product of all the elements of nums except nums[i].\n\nEach product is guaranteed to fit in a 32-bit integer.\n\nFollow-up: Could you solve it in O(n)O(n) time without using the division operation?\n\nExample 1:\n\nInput: nums = [1,2,4,6]\n\nOutput: [48,24,12,8]\n\nExample 2:\n\nInput: nums = [-1,0,1,2,3]\n\nOutput: [0,-6,0,0,0]\n\nConstraints:\n\n    2 <= nums.length <= 1000\n    -20 <= nums[i] <= 20",
        "code": "class Solution:\n    def productExceptSelf(self, nums):\n        # list of one's\n        prefix = [1] * (len(nums))\n\n        for i in range(1, len(nums)):\n            # calculate the prefix of the first len(nums) - 1 elements\n            prefix[i] = prefix[i-1] * nums[i-1]\n                \n        # using postfix as a number rather than an array\n        postfix = 1\n        \n        # reversing backwards through the list\n        for i in range(len(nums) - 1, -1, -1):\n            # if you times the prefix of an element and the postfix of the element, then you will have the product of all the elements besides itself\n            # prefix of 6 in [1, 2, 4, 6] is 8\n            # because 6 is at the end, the postfix starts as 1\n            # 8 * 1 = 8 a which is the product of every number besides 6\n            # for 4 ---> prefix = 2, postfix = 1 * 6 ---> 2 * 6 = 12 which is the correct answer\n            prefix[i] *= postfix\n            # adding numbers to the postfix as usual\n            postfix *= nums[i]\n        \n        return prefix"
    },
    "13": {
        "tag": [
            "560",
            "prefix_sum"
        ],
        "title": "Subarray Sum Equals K",
        "hint": "prefix_sum, the difference in sums over time can tell you about the sums between different elements",
        "note": "the prefix_sum before any array is 0. if we calculate the prefix sum along the way (is a int variable) and see that we have seen a sum before that is the difference between the current prefix_sum and the target sum, we know that the elements in between those points are equal to the target sum. For the problem, they only want the count/occurrence, so we don't need to save the indices but we do need to save the frequencies that we've seen particular sum. Check code comments for more.",
        "problem": "Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.\n\nA subarray is a contiguous non-empty sequence of elements within an array.\n\n \n\nExample 1:\n\nInput: nums = [1,1,1], k = 2\nOutput: 2\n\nExample 2:\n\nInput: nums = [1,2,3], k = 3\nOutput: 2\n\n \n\nConstraints:\n\n    1 <= nums.length <= 2 * 104\n    -1000 <= nums[i] <= 1000\n    -107 <= k <= 107",
        "code": "from collections import defaultdict\n\nclass Solution:\n\tdef subarraySum(self, nums, k: int) -> int:\n\t\t# use a hash map to keep count of the frequency at which you seen a certain sum so far\n\t\t# the frequency matters because if you saw a sum of three at index 2 and at index 4, by the time you get to index 7 and the sum is now 6, those would be to instances in which the sum has changed by 3 (2 ---> 7 & 4 ---> 7) and we want to count those both\n\t\tprefix_sum_count = defaultdict(int)\n        \n\t\t# we know that the prefix_sum before any array is 0, with a frequency of one\n\t\tprefix_sum_count[0] = 1  # Initialize with 0 prefix sum count for the base case\n\t\tcurrent_sum = 0\n\t\tcount = 0\n\t\t\n\t\tfor num in nums:\n\t\t\tcurrent_sum += num\n            \n\t\t\t# check if we've seen the difference before\n\t\t\tif (current_sum - k) in prefix_sum_count:\n            \n\t\t\t\t# if so, get the frequency at which we've seen this difference and added to the count\n\t\t\t\tcount += prefix_sum_count[current_sum - k]\n\t\t\t\n            # increase the frequency that we've seen this particular sum\n\t\t\tprefix_sum_count[current_sum] += 1\n\t\t\n\t\treturn count"
    },
    "14": {
        "tag": [
            ""
        ],
        "title": "Duplicate Integer",
        "hint": null,
        "note": null,
        "problem": "Given an integer array nums, return true if any value appears more than once in the array, otherwise return false.\n\nExample 1:\n\nInput: nums = [1, 2, 3, 3]\n\nOutput: true\n\nExample 2:\n\nInput: nums = [1, 2, 3, 4]\n\nOutput: false",
        "code": "class Solution:\n    def hasDuplicate(self, nums: List[int]) -> bool:\n        hashset = set()\n\n        for n in nums:\n            if n in hashset:\n                return True\n            hashset.add(n)\n        return False"
    },
    "15": {
        "tag": [
            "hash"
        ],
        "title": "Is Anagram",
        "hint": "hashmap",
        "note": "you basically want to count the frequency of each character in the string and compare the dictionaries to make sure that they're the same\nyou can write a good base case checking the length first",
        "problem": "Given two strings s and t, return true if the two strings are anagrams of each other, otherwise return false.\n\nAn anagram is a string that contains the exact same characters as another string, but the order of the characters can be different.\n\nExample 1:\n\nInput: s = \"racecar\", t = \"carrace\"\n\nOutput: true\n\nExample 2:\n\nInput: s = \"jar\", t = \"jam\"\n\nOutput: false\n\nConstraints:\n\n    s and t consist of lowercase English letters.",
        "code": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n\n        countS, countT = {}, {}\n\n        for i in range(len(s)):\n            countS[s[i]] = 1 + countS.get(s[i], 0)\n            countT[t[i]] = 1 + countT.get(t[i], 0)\n        return countS == countT"
    },
    "16": {
        "tag": [
            "hash"
        ],
        "title": "Two Integer Sum",
        "hint": "hash, save the index",
        "note": "you basically want to save the difference of the current number and target sum and its index \nwhile traversing the array if you see this difference, get the index of the first number(diff) in the current number(i)",
        "problem": "Given an array of integers nums and an integer target, return the indices i and j such that nums[i] + nums[j] == target and i != j.\n\nYou may assume that every input has exactly one pair of indices i and j that satisfy the condition.\n\nReturn the answer with the smaller index first.\n\nExample 1:\n\nInput: \nnums = [3,4,5,6], target = 7\n\nOutput: [0,1]\n\nExplanation: nums[0] + nums[1] == 7, so we return [0, 1].\n\nExample 2:\n\nInput: nums = [4,5,6], target = 10\n\nOutput: [0,2]\n\nExample 3:\n\nInput: nums = [5,5], target = 10\n\nOutput: [0,1]\n\nConstraints:\n\n    2 <= nums.length <= 1000\n    -10,000,000 <= nums[i] <= 10,000,000\n    -10,000,000 <= target <= 10,000,000",
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        prevMap = {}  # val -> index\n\n        for i, n in enumerate(nums):\n            diff = target - n\n            \n            if diff in prevMap:\n                return [prevMap[diff], i]\n            \n            prevMap[n] = i"
    },
    "17": {
        "tag": [
            "hash"
        ],
        "title": "Anagram Groups",
        "hint": null,
        "note": "Lesson: ord can be used\nthe normal solution would be O(m*n*log(n)) solution in which we sort all of the strings and save that as the key, counting frequency\nthe solution is O(m*n) in which M is the number of strings and N is the average length of each string",
        "problem": "Given an array of strings strs, group all anagrams together into sublists. You may return the output in any order.\n\nAn anagram is a string that contains the exact same characters as another string, but the order of the characters can be different.\n\nExample 1:\n\nInput: strs = [\"act\",\"pots\",\"tops\",\"cat\",\"stop\",\"hat\"]\n\nOutput: [[\"hat\"],[\"act\", \"cat\"],[\"stop\", \"pots\", \"tops\"]]\n\nExample 2:\n\nInput: strs = [\"x\"]\n\nOutput: [[\"x\"]]\n\nExample 3:\n\nInput: strs = [\"\"]\n\nOutput: [[\"\"]]\n\nConstraints:\n\n    1 <= strs.length <= 1000.\n    0 <= strs[i].length <= 100\n    strs[i] is made up of lowercase English letters.",
        "code": "class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        ans = defaultdict(list)\n\n        for s in strs:\n            # 26 for a - z\n            count = [0] * 26\n            for char in s:\n                # returns the ASCII value\n                count[ord(char) - ord(\"a\")] += 1\n            \n            # cannot save a list as a key, so convert it to tuple\n            ans[tuple(count)].append(s)\n        \n        return ans.values()"
    },
    "18": {
        "tag": [
            "hash"
        ],
        "title": "Top K Elements in List",
        "hint": "user frequency hash map and frequency array",
        "note": "nums: [1,2,2,2,2,4,4]\nStep One: \n - keep count of the frequency. Every time you see a number, up the count\nnum_count: {1: 1, 2: 4, 4: 2}\n\nNext: \n - convert into a frequency array\n - the frequency array is the length of original array because you cannot have a single number that occurs more than all the numbers that exist\n - the frequency array should be a length + 1 because if you have a frequency of 7, you need to use the 8th index which we know is \"7\"\n\nfreq_as_idx: [[], [1], [4], [], [2], [], [], []]\n(1 has a frequency of 1, 4 has a frequency of 2, 2 has a frequency of 4)\n\nNext:\n - loop backwards through the array\n - you'll see the highest frequency number first\n - keep collecting until you see the number needed\n\nresult.append(2) \nresult.append(4)\nif len(result) == nums_needed: (T)\nreturn [2, 4]",
        "problem": "Given an integer array nums and an integer k, return the k most frequent elements within the array.\n\nThe test cases are generated such that the answer is always unique.\n\nYou may return the output in any order.\n\nExample 1:\n\nInput: nums = [1,2,2,3,3,3], k = 2\n\nOutput: [2,3]\n\nExample 2:\n\nInput: nums = [7,7], k = 1\n\nOutput: [7]\n\nConstraints:\n\n    1 <= nums.length <= 10^4.\n    -1000 <= nums[i] <= 1000\n    1 <= k <= number of distinct elements in nums.",
        "code": "def topKFrequent(nums, nums_needed):\n    num_count = {}\n    freq_as_idx = [[] for i in range(len(nums) + 1)]\n\n    \n    for num in nums:\n        num_count[num] = 1 + num_count.get(num, 0)\n            \n\n    for num, freq in num_count.items():\n        freq_as_idx[freq].append(num)\n\n    \n    result = []\n    for i in range(len(freq_as_idx) - 1, 0, -1):\n        for num in freq_as_idx[i]:\n            result.append(num)\n            if len(result) == nums_needed:\n                return result\n\n\nf = topKFrequent([1,2,2,2,2,4,4], 2)\n# f = topKFrequent([2,2,2,2,2,2,2], 2)\nprint(f)"
    },
    "19": {
        "tag": [
            ""
        ],
        "title": "String Encode and Decode",
        "hint": null,
        "note": "join the string with the length of the string plus a '#'\nthis will work because even if there are more numbers and #s, the initial one will cover the length:\n['1#', 'good', 'ha2#ppy'] ---> 2#1#4#good7#ha2#ppy\nwhen decoding we will look at the *first* number-hash combination: 2# therefore regardless with the next two characters say, we know that the part of the original string:\n2# ---> {1#}\n4# ---> {good}\n7# ---> {ha2#ppy}\n\nLesson: the number was what really is allowing us to skip over the characters/cause the decoding\nthe hashes just so that we know where the number actually stops so that we don't confuse '271' if we mean '2#71'",
        "problem": "Design an algorithm to encode a list of strings to a single string. The encoded string is then decoded back to the original list of strings.\n\nPlease implement encode and decode\n\nExample 1:\n\nInput: [\"neet\",\"code\",\"love\",\"you\"]\n\nOutput:[\"neet\",\"code\",\"love\",\"you\"]\n\nExample 2:\n\nInput: [\"we\",\"say\",\":\",\"yes\"]\n\nOutput: [\"we\",\"say\",\":\",\"yes\"]\n\nConstraints:\n\n    0 <= strs.length < 100\n    0 <= strs[i].length < 200\n    strs[i] contains only UTF-8 characters.",
        "code": "class Solution:\n\t\n\tdef encode(self, strs: List[str]) -> str:\n\t\tres = \"\"\n\t\tfor string in strs:\n\t\t\tres += str(len(string)) + \"#\" + string\n\t\treturn res\n\n\tdef decode(self, string: str) -> List[str]:\n\t\tres = []\n\t\ti = 0\n\t\t\n\t\twhile i < len(string):\n\t\t\tj = i\n\t\t\twhile string[j] != '#':\n\t\t\t\tj += 1\n\t\t\tlength = int(string[i:j])\n\t\t\t# j is pointing to the '#', so j + 1 will point to the string after\n\t\t\ti = j + 1\n\t\t\t# j is moved after the string, pointing at the next number-# combo\n\t\t\tj = i + length\n\t\t\t# capture the string\n\t\t\tres.append(string[i:j])\n\t\t\t# move i to the start of the next combo\n\t\t\ti = j\n\t\t\t\n\t\treturn res"
    },
    "20": {
        "tag": [
            "hash"
        ],
        "title": "Valid Sudoku",
        "hint": "three hashmaps",
        "note": "you're basically going to have a hashmap for the rows\nrows[0] = [1, 2, 7, 8] ---> represents the values in the first row of the sudoku board\nwhen you see a coordinate (r, c), get its value (board[r][c]), check the row and col hashmaps to see if that value already exists\nboard[0][3] = 6\nrows[0] = [1, 2, 7, 8]\ncol[3] = [3, 5, 9]\n\nis 6 already in rows[0]? ---> No\nis 6 already in col[3]? ---> No\nupdate these hashmaps and continue the search\n\nin order to check the 3 x 3 grid in the sudoku, will have another hashmap representing that area\nwe know that (0, 1, 2), (3, 4, 5), (6, 7, 8) all produce the same quotient with integer division by three so that's how we segment out an area\nwe know that coordinate (2, 5) points to the same box as (0, 4) because when they integer divide, it will all point to box (0, 1) which is the second box in the first row\n\nLesson: the trick here is mostly getting creative in trying to find out how the coordinates in each box can be grouped together/related to each other.in this case it was that they all share the same quotients when they were divided by three",
        "problem": "You are given a a 9 x 9 Sudoku board board. A Sudoku board is valid if the following rules are followed:\n\n    Each row must contain the digits 1-9 without duplicates.\n    Each column must contain the digits 1-9 without duplicates.\n    Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without duplicates.\n\nReturn true if the Sudoku board is valid, otherwise return false\n\nNote: A board does not need to be full or be solvable to be valid.\n<a href=\"https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/0be40c5d-2d18-42b8-261b-13ca50de4100/public\" target=\"_blank\">Graphic</a>\n\nExample 1:\n\nInput: board = \n[[\"1\",\"2\",\".\",\".\",\"3\",\".\",\".\",\".\",\".\"],\n [\"4\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\n [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\".\",\"3\"],\n [\"5\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"4\"],\n [\".\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"5\"],\n [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n [\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\"],\n [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"8\"],\n [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n\nOutput: true\n\nExample 2:\n\nInput: board = \n[[\"1\",\"2\",\".\",\".\",\"3\",\".\",\".\",\".\",\".\"],\n [\"4\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\n [\".\",\"9\",\"1\",\".\",\".\",\".\",\".\",\".\",\"3\"],\n [\"5\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"4\"],\n [\".\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"5\"],\n [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n [\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\"],\n [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"8\"],\n [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n\nOutput: false\n\nExplanation: There are two 1's in the top-left 3x3 sub-box.\n\nConstraints:\n\n    board.length == 9\n    board[i].length == 9\n    board[i][j] is a digit 1-9 or '.'.",
        "code": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        cols = defaultdict(set)\n        rows = defaultdict(set)\n        squares = defaultdict(set)  # key = (r /3, c /3)\n\n        for r in range(9):\n            for c in range(9):\n                if board[r][c] == \".\":\n                    continue\n                if (\n                    board[r][c] in rows[r]\n                    or board[r][c] in cols[c]\n                    or board[r][c] in squares[(r // 3, c // 3)]\n                ):\n                    return False\n                cols[c].add(board[r][c])\n                rows[r].add(board[r][c])\n                squares[(r // 3, c // 3)].add(board[r][c])\n\n        return True"
    },
    "21": {
        "tag": [
            "hash"
        ],
        "title": "Longest Consecutive Sequence",
        "hint": "sequences do not have to be contiguous\nit's about finding the minimum",
        "note": "this problem uses a creative way to find the minimum at each point in the array\nnums = [2,20,4,10,3,4,5] (turn into a set to remove duplicates)\nin nums, '2, 20, 10' are all the minimums of their own sequence\nwe know that 2 as a minimum of a sequence for example because there is no (n - 1) ---> (2 - 1) ---> 1 in the list. because there is no 19 and list we know that 20 would be a minimum of its own sequence\nso once we find a minimum, we simply check if it's value  + 1,  + 2,  + 3... etc exist in the list, all the while counting the length\nonce we have 2, we check it 3 is present then we check in 4 is present until we don't find the next value\nsave the length that this current point",
        "problem": "Given an array of integers nums, return the length of the longest consecutive sequence of elements.\n\nA consecutive sequence is a sequence of elements in which each element is exactly 1 greater than the previous element.\n\nYou must write an algorithm that runs in O(n) time.\n\nExample 1:\n\nInput: nums = [2,20,4,10,3,4,5]\n\nOutput: 4\n\nExplanation: The longest consecutive sequence is [2, 3, 4, 5].\n\nExample 2:\n\nInput: nums = [0,3,2,5,4,6,1,1]\n\nOutput: 7\n\nConstraints:\n\n    0 <= nums.length <= 1000\n    -10^9 <= nums[i] <= 10^9",
        "code": "class Solution:\n    def longestConsecutive(self, nums):\n        numSet = set(nums)\n        longest = 0\n\n        for num in numSet:\n            # check if this is the start of the sequence\n            # you know this is the start of a sequence if there is not a number directly 1 less than it\n            if (num - 1) not in numSet:\n                length = 1\n                # when you have found the start of a sequence, keep checking the next number to see how long the sequence ss\n                while (num + length) in numSet:\n                    length += 1\n                longest = max(length, longest)\n            # if it is not the start of a sequence keep iterating forward\n        return longest"
    },
    "22": {
        "tag": [
            "two_pointer"
        ],
        "title": "Is Palindrome",
        "hint": null,
        "note": "loop over non-alphaNum characters",
        "problem": "Given a string s, return true if it is a palindrome, otherwise return false.\n\nA palindrome is a string that reads the same forward and backward. It is also case-insensitive and ignores all non-alphanumeric characters.\n\nExample 1:\n\nInput: s = \"Was it a car or a cat I saw?\"\n\nOutput: true\n\nExplanation: After considering only alphanumerical characters we have \"wasitacaroracatisaw\", which is a palindrome.\n\nExample 2:\n\nInput: s = \"tab a cat\"\n\nOutput: false\n\nExplanation: \"tabacat\" is not a palindrome.\n\nConstraints:\n\n    1 <= s.length <= 1000\n    s is made up of only printable ASCII characters.",
        "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        l, r = 0, len(s) - 1\n\n        while l < r:\n            while l < r and not self.alphaNum(s[l]):\n                l += 1\n            while r > l and not self.alphaNum(s[r]):\n                r -= 1\n            if s[l].lower() != s[r].lower():\n                return False\n            l, r = l + 1, r - 1\n        return True\n    \n    def alphaNum(self, c):\n        return (ord('A') <= ord(c) <= ord('Z') or \n                ord('a') <= ord(c) <= ord('z') or \n                ord('0') <= ord(c) <= ord('9'))"
    },
    "23": {
        "tag": [
            "two_pointer"
        ],
        "title": "Two Integer Sum II",
        "hint": null,
        "note": null,
        "problem": "Given an array of integers numbers that is sorted in non-decreasing order.\n\nReturn the indices (1-indexed) of two numbers, [index1, index2], such that they add up to a given target number target and index1 < index2. Note that index1 and index2 cannot be equal, therefore you may not use the same element twice.\n\nThere will always be exactly one valid solution.\n\nYour solution must use O(1)O(1) additional space.\n\nExample 1:\n\nInput: numbers = [1,2,3,4], target = 3\n\nOutput: [1,2]\n\nExplanation:\nThe sum of 1 and 2 is 3. Since we are assuming a 1-indexed array, index1 = 1, index2 = 2. We return [1, 2].\n\nConstraints:\n\n    2 <= numbers.length <= 1000\n    -1000 <= numbers[i] <= 1000\n    -1000 <= target <= 1000",
        "code": "class Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        l, r = 0, len(numbers) - 1\n\n        while l < r:\n            curSum = numbers[l] + numbers[r]\n\n            if curSum > target:\n                r -= 1\n            elif curSum < target:\n                l += 1\n            else:\n                return [l + 1, r + 1]"
    },
    "24": {
        "tag": [
            "26",
            "two_pointer"
        ],
        "title": "Remove Duplicates from Sorted Array",
        "hint": null,
        "note": "[0,0,1,1,1,1,2,3,3]\neach time you detect a number change, that means you have found a new unique number\n0 ---> 1, 1 ---> 2, we just save each time we see the new number\nthe problem already lets us know that sorted so we know all the numbers will be next to each other\n\nLesson: this mostly has to do with how you should look at sorted lists when it comes to duplicates",
        "problem": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.\n\nConsider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\n\n    Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.\n    Return k.\n\n\nExample 1:\n\nInput: nums = [1,1,2]\nOutput: 2, nums = [1,2,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\nExample 2:\n\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n \n\nConstraints:\n\n    1 <= nums.length <= 3 * 104\n    -100 <= nums[i] <= 100\n    nums is sorted in non-decreasing or",
        "code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        next_elem = 1\n        for i in range(1, len(nums)):\n            # if there is a change in number\n            if nums[i] != nums[i - 1]:\n                nums[next_elem] = nums[i]\n                next_elem += 1\n        return next_elem"
    },
    "25": {
        "tag": [
            "80",
            "two_pointer"
        ],
        "title": "Remove Duplicates from Sorted Array II",
        "hint": "think of the problem as shifting down numbers of the array",
        "note": "any list 0-2 elements won't have more than the allowed number of duplicates, so it's automatically valid\nthe best way to think of this problem is that were truly shifting down elements of the array\nwe're moreso just determining which elements to shift down\nif we've seen the same element more than twice, we don't need to continue shifting that number\nLesson: consider all edge cases and scenarios",
        "problem": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\n\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\n\nReturn k after placing the final result in the first k slots of nums.\n\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\n\nCustom Judge:\n\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.\n\n \n\nExample 1:\n\nInput: nums = [1,1,1,2,2,3]\nOutput: 5, nums = [1,1,2,2,3,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\nExample 2:\n\nInput: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7, nums = [0,0,1,1,2,3,3,_,_]\nExplanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n \n\nConstraints:\n\n    1 <= nums.length <= 3 * 104\n    -104 <= nums[i] <= 104\n    nums is sorted in non-decreasing order.",
        "code": "class Solution:\n\tdef removeDuplicates(self, nums):\n\t   \n\t\tif len(nums) <= 2: \n\t\t\treturn len(nums)\n\t\t\n\t\tcount = 1\n\t\tnext = 1\n\t\t\n\t\tfor i in range(1, len(nums)):\n\t\t\tif nums[i] == nums[i - 1]:\n\t\t\t\tcount += 1\n\t\t\telse:\n\t\t\t\t# we've seen a new number\n                count = 1\n\t\t\t\t\n\t\t\t# shifting down elements if we haven't seen them more than twice\n            if count <= 2:\n\t\t\t\tnums[next] = nums[i]\n\t\t\t\tnext += 1\n\n\t\treturn next\n\n# Solution().removeDuplicates([1,1,1,2,2,3])\nSolution().removeDuplicates([0,0,0,1,1,1,1,2,3,3, 4])"
    },
    "26": {
        "tag": [
            "two_pointer"
        ],
        "title": "Max Water Container / Container With Most Water",
        "hint": "only the minimum matters",
        "note": null,
        "problem": "You are given an integer array heights where heights[i] represents the height of the ithith bar.\n\nYou may choose any two bars to form a container. Return the maximum amount of water a container can store.\n\nExample 1:\n<a href=\"https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/77f004c6-e773-4e63-7b99-a2309303c700/public\" target=\"_blank\">Graphic</a>\n\nInput: height = [1,7,2,5,4,7,3,6]\n\nOutput: 36\n\nExample 2:\n\nInput: height = [2,2,2]\n\nOutput: 4\n\nConstraints:\n\n    2 <= height.length <= 1000\n    0 <= height[i] <= 1000",
        "code": "class Solution:\n    def maxArea(self, heights: List[int]) -> int:\n        l, r = 0, len(heights) - 1\n        res = 0\n        previous = 0\n\n        while l < r:\n            current_minimum = min(heights[l], heights[r])\n\n            # you only need to calculate a new area if you have a new, increased minimum\n            # because every other bar would just be less distance with an even lower/equal minimum\n            if current_minimum > previous or l == 0:\n                res = max(res, current_minimum * (r - l))\n                previous = current_minimum\n            \n            if heights[l] < heights[r]:\n                l += 1\n            \n            # if the two bars are equal doesn't matter whether you move left or right\n            # because the area will only be greater than those two equal bars, if there are\n            # two bars that are both greater than those equal bars, and based on the algorithm\n            # no matter which way you move, if that's the case, you will find both bars\n            elif heights[r] <= heights[l]:\n                r -= 1\n            \n        return res"
    },
    "27": {
        "tag": [
            "two_pointer"
        ],
        "title": "Trapping Rain Water",
        "hint": "you will oscillate between evaluating the left and right values",
        "note": "you are iterating through the array trying to determine how much water can sit on top of a particular bar\nin order to determine this you need to know your left and right boundaries\nyour bar does not have a left boundary if there is no left value that is greater than it\nOnce you have determined your left and right boundary, then you can know how much water sits on top of your bar once you subtract the height of your bar from the minimum boundary, whether it be your left or right\nIn fact, since the minimum boundaries the only one that matters (doesn't matter how tall your maximum boundary is , as your minimum boundary sets how high the water can go )\nTherefore we often only really need to know the minimum boundary to our bar\nwe will go back and forth between evaluating bars from the right and left depending on whether the minimum boundary is to the left or right\nif the minimum/lower boundary is to the left we will  be evaluating bars on the left, if at any point the minimum boundary is comming from the right, we will start evaluating bars from the right\nWe want to keep track of the highest bar to the left and the right at any point in time (because these are boundaries). Still, between these two bars one will be lower than the other (or equal)",
        "problem": "You are given an array non-negative integers heights which represent an elevation map. Each value heights[i] represents the height of a bar, which has a width of 1.\n\nReturn the maximum area of water that can be trapped between the bars.\n\nExample 1:\n<a href=\"https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/0c25cb81-1095-4382-fff2-6ef77c1fd100/public\" target=\"_blank\">Graphic</a>\n\nInput: height = [0,2,0,3,1,0,1,3,2,1]\n\nOutput: 9\n\nConstraints:\n\n    1 <= height.length <= 1000\n    0 <= height[i] <= 1000",
        "code": "class Solution:\n    def trap(self, height):\n        if not height:\n            return 0\n\n        l = 0\n        r = len(height) - 1\n        \n        leftMax = height[l]\n        rightMax = height[r]\n        res = 0\n        \n        while l < r:\n            \n            if leftMax < rightMax:\n                l += 1\n                leftMax = max(leftMax, height[l])\n                res += leftMax - height[l]\n            \n            else:\n                r -= 1\n                rightMax = max(rightMax, height[r])\n                res += rightMax - height[r]\n        \n        return res\n\nSolution().trap([0,1,0,2,1,0,1,3,2,1,2,1])"
    },
    "28": {
        "tag": [
            "two_pointer"
        ],
        "title": "Three Integer Sum",
        "hint": "must be zero-sum, two_pointer, O(n^2) solution",
        "note": "you will sort the array\nyou will pick a number as the start number ( the start number will change at the start of each loop )\nyou will look at every other number after that point to try to find two numbers that will cause a sum of zero, using two pointers\n[-1,0,1,2,-1,-4] ---> [-4, -1, -1, 0, 1, 2]\nso -4 would be our first number (of the potential three sum) and then the left pointer would point at -1, the right pointer would point at -2\nif the sum is too large that we move down the right pointer, if the sum is too small then we move the left pointer\nskip over duplicates",
        "problem": "FIND TRIPLETS WHERE SUM IS EQUAL TO ZERO\nGiven an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] where nums[i] + nums[j] + nums[k] == 0, and the indices i, j and k are all distinct.\n\nThe output should not contain any duplicate triplets. You may return the output and the triplets in any order.\n\nExample 1:\n\nInput: nums = [-1,0,1,2,-1,-4]\n\nOutput: [[-1,-1,2],[-1,0,1]]\n\nExplanation:\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\n\nExample 2:\n\nInput: nums = [0,1,1]\n\nOutput: []\n\nExplanation: The only possible triplet does not sum up to 0.\n\nExample 3:\n\nInput: nums = [0,0,0]\n\nOutput: [[0,0,0]]\n\nExplanation: The only possible triplet sums up to 0.\n\nConstraints:\n\n    3 <= nums.length <= 1000\n    -10^5 <= nums[i] <= 10^5",
        "code": "class Solution:\n    def threeSum(self, nums):\n        res = []\n        # sorted array\n        nums.sort()\n\n        # picking the first of the three numbers\n        for idx, num in enumerate(nums):\n            # if your first value is not negative then you won't find any sum the equals zero with the remaining left and right pointers\n            if num > 0:\n                break\n\n            # skip over duplicate values\n            if idx > 0 and num == nums[idx - 1]:\n                continue\n\n            # picking the second and third of the three numbers\n            l = idx + 1\n            r = len(nums) - 1\n            \n            while l < r:\n                threeSum = num + nums[l] + nums[r]\n                \n                # if the sum is too large\n                if threeSum > 0:\n                    r -= 1\n                # if the sum is to small\n                elif threeSum < 0:\n                    l += 1\n                \n                else:\n                    res.append([num, nums[l], nums[r]])\n                    # We must move both values. If the numbers we have are -1, -1, 2\n                    # the only way you would be able to move just one pointer and still get a \n                    # valid sum is if you come up with another identical set -1, -1, 2 and we \n                    # don't want to include duplicate solutions\n                    l += 1\n                    r -= 1\n                    \n                    # # skip over duplicate values\n                    while nums[l] == nums[l - 1] and l < r:\n                        l += 1\n                        \n        return res"
    },
    "29": {
        "tag": [
            "math"
        ],
        "title": "Car Fleet",
        "hint": "How many hours will it take?",
        "note": "you just want to figure out how long it's going to take each card to get the destination. If a car behind another car takes less time the you know that it will be a part of the fleet in front of it\n\nIf a car will take more time than the car in front of it, then it will start its own fleet as it won't arrive at the same time as the fleet in front of it",
        "problem": "There are n cars at given miles away from the starting mile 0, traveling to reach the mile target.\n\nYou are given two integer array position and speed, both of length n, where position[i] is the starting mile of the ith car and speed[i] is the speed of the ith car in miles per hour.\n\nA car cannot pass another car, but it can catch up and then travel next to it at the speed of the slower car.\n\nA car fleet is a car or cars driving next to each other. The speed of the car fleet is the minimum speed of any car in the fleet.\n\nIf a car catches up to a car fleet at the mile target, it will still be considered as part of the car fleet.\n\nReturn the number of car fleets that will arrive at the destination.\n\nExample 1:\n\nInput: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]\n\nOutput: 3\n\nExplanation:\n\n    The cars starting at 10 (speed 2) and 8 (speed 4) become a fleet, meeting each other at 12. The fleet forms at target.\n    The car starting at 0 (speed 1) does not catch up to any other car, so it is a fleet by itself.\n    The cars starting at 5 (speed 1) and 3 (speed 3) become a fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.\n\n\nExample 1:\n\nInput: target = 10, position = [1,4], speed = [3,2]\n\nOutput: 1\n\nExplanation: The cars starting at 1 (speed 3) and 4 (speed 2) become a fleet, meeting each other at 10, the destination.\n\nExample 2:\n\nInput: target = 10, position = [4,1,0,7], speed = [2,2,1,1]\n\nOutput: 3\n\nExplanation: The cars starting at 4 and 7 become a fleet at position 10. The cars starting at 1 and 0 never catch up to the car ahead of them. Thus, there are 3 car fleets that will arrive at the destination.\n\nConstraints:\n\n    n == position.length == speed.length.\n    1 <= n <= 1000\n    0 < target <= 1000\n    0 < speed[i] <= 100\n    0 <= position[i] < target\n    All the values of position are unique.",
        "code": "class Solution:\n    def carFleet(self, target, position, speed):\n        target = target\n        pairs = [(position[i], speed[i]) for i in range(len(position))]\n        fleets = 0\n        \n        # kp: evaluate the cars closest to the target first\n        pairs.sort(reverse=True)\n        pairs = pairs\n        \n        # represents the longest time it'll take a fleet to arrive (no fleet will be at target at time 0)\n        slowest_fleet_time = 0\n        \n        for pos, speed in pairs:\n            distance_from_target = target - pos\n            hours_til_target = distance_from_target / speed\n            # kp: if this car takes longer than the fleet in front of it\n            if hours_til_target > slowest_fleet_time:\n                fleets += 1\n                slowest_fleet_time = hours_til_target\n            else:\n                # kp: if it takes the same time or shorter, then we know it is a part of the previous fleet\n                pass\n        \n        return fleets\n    \n\nSolution().carFleet(10, [4, 1, 0, 7], [2, 2, 1, 1])\n\nExample:\ncarFleet(10, [4, 1, 0, 7], [2, 2, 1, 1])\n    target = 10\n    pairs = [(4, 2), (1, 2), (0, 1), (7, 1)]\n    fleets = 0\n    # evaluate the cars closest to the target first\n    pairs = [(7, 1), (4, 2), (1, 2), (0, 1)]\n    slowest_fleet_time = 0\n        \n        pos: 7\n        speed: 1\n        distance_from_target = 3\n        hours_til_target = 3.0\n        # if this car takes longer than the fleet in front of it\n        if hours_til_target > slowest_fleet_time:\n        if 3.0 > 0: (T)\n            fleets += 1\n            slowest_fleet_time = hours_til_target\n        \n        pos: 4\n        speed: 2\n        distance_from_target = 6\n        hours_til_target = 3.0\n        # if this car takes longer than the fleet in front of it\n        if hours_til_target > slowest_fleet_time:\n        if 3.0 > 3.0: (F)\n        else:\n            # if it takes the same time or shorter, then we know it is a part of the previous fleet\n        \n        pos: 1\n        speed: 2\n        distance_from_target = 9\n        hours_til_target = 4.5\n        # if this car takes longer than the fleet in front of it\n        if hours_til_target > slowest_fleet_time:\n        if 4.5 > 3.0: (T)\n            fleets += 1\n            slowest_fleet_time = hours_til_target\n        \n        pos: 0\n        speed: 1\n        distance_from_target = 10\n        hours_til_target = 10.0\n        # if this car takes longer than the fleet in front of it\n        if hours_til_target > slowest_fleet_time:\n        if 10.0 > 4.5: (T)\n            fleets += 1\n            slowest_fleet_time = hours_til_target"
    },
    "30": {
        "tag": [
            "stack",
            "84"
        ],
        "title": "Largest Rectangle in Histogram",
        "hint": "this is a stack problem, think about what you can use the indices for",
        "note": "Lesson: saving the indices of all values was key for this",
        "problem": "Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.\n\nExample 1:\n\n<a href=\"https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg\" target=\"_blank\">Graphic</a>\n\nInput: heights = [2,1,5,6,2,3]\nOutput: 10\nExplanation: The above is a histogram where width of each bar is 1.\nThe largest rectangle is shown in the red area, which has an area = 10 units.\n\nExample 2:\n\n<a href=\"https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg\" target=\"_blank\">Graphic</a>\n\nInput: heights = [2,4]\nOutput: 4\n\n\nConstraints:\n\n    1 <= heights.length <= 105\n    0 <= heights[i] <= 104",
        "code": "class Solution:\n    \n    def largestRectangleArea(self, heights):\n        \"\"\" \n        place the first bar on the stack\n        loop through remaining bars\n        while the current bar is less than what's on the stack\n            Pop off the value\n            evaluate the distance between the current index and the index in its stack (which represents the start of its span)\n            save the span_start of each bar\n        \n        add the current bar onto the stack with the span start of the last that wass removed, the span start should be the current index if none were removed\n        \n        if the current bar is  ==  or > Whatt's on the stack\n            push the current value and its index to the stack\n            \n        once the for loop ends\n        go backwards through the stack, popping off each value and evaluating its index versus the length of the list, calculating the new area\n        \n        \"\"\" \n        stack = [[heights[0], 0]]\n        max_area = 0\n        len_heights = len(heights)\n        for i in range(1, len(heights)):\n            height = heights[i]\n            span_start = i\n            \n            while stack and (height < stack[-1][0]):\n                previous_height, span_start = stack.pop()\n                max_area = max(max_area, (i - span_start) * previous_height)\n                    \n            \n            stack.append([height, span_start])\n                                            \n        while stack:\n            # you actually don't need to pop, you can just write a for loop going through the stack since we won't be using it after this\n            previous_height, span_start = stack.pop()\n            max_area = max(max_area, (len_heights - span_start) * previous_height)                \n                   \nSolution().largestRectangleArea([2,4])\n\nEXAMPLE:\nlargestRectangleArea([2, 1, 5, 6, 2, 3])\n    stack = [[2, 0]]\n    \n    i: 1\n    height = 1\n    previous = [[2, 0]].pop()\n    max_area = max(0, 2)\n    max_area = 2\n    \n    [].append([1, 0])\n    \n    i: 2\n    height = 5\n    [[1, 0]].append([5, 2])\n    \n    i: 3\n    height = 6\n    [[1, 0], [5, 2]].append([6, 3])\n    \n    i: 4\n    height = 2\n    previous = [[1, 0], [5, 2], [6, 3]].pop()\n    max_area = max(2, 6)\n    max_area = 6\n    \n    previous = [[1, 0], [5, 2]].pop()\n    max_area = max(6, 10)\n    max_area = 10\n    \n    [[1, 0]].append([2, 2])\n    \n    i: 5\n    height = 3\n    [[1, 0], [2, 2]].append([3, 5])\n    \n    while stack:\n    while [[1, 0], [2, 2], [3, 5]]: (T)\n        previous = [[1, 0], [2, 2], [3, 5]].pop()\n        max_area = max(10, 3)\n        max_area = 10\n        \n        previous = [[1, 0], [2, 2]].pop()\n        max_area = max(10, 8)\n        max_area = 10\n        \n        previous = [[1, 0]].pop()\n        max_area = max(10, 6)\n        max_area = 10"
    },
    "31": {
        "tag": [
            "algorithm"
        ],
        "title": "Binary Search",
        "hint": "m = l + ((r - l) // 2)  # (l + r) // 2 can lead to overflow",
        "note": null,
        "problem": "write the algorithm for a binary search",
        "code": "class Solution:\n    def search(self, nums, target):\n        l, r = 0, len(nums) - 1\n\n        while l <= r:\n            m = l + ((r - l) // 2)  # (l + r) // 2 can lead to overflow\n            if nums[m] > target:\n                r = m - 1\n            elif nums[m] < target:\n                l = m + 1\n            else:\n                return m\n        return -1\n \n                   \nSolution().search([2,1,5,6,2,3])"
    },
    "32": {
        "tag": [
            "binary_search"
        ],
        "title": "Search 2D Matrix",
        "hint": "double binary search",
        "note": null,
        "problem": "You are given an m x n 2-D integer array matrix and an integer target.\n\n    Each row in matrix is sorted in non-decreasing order.\n    The first integer of every row is greater than the last integer of the previous row.\n\nReturn true if target exists within matrix or false otherwise.\n\nCan you write a solution that runs in O(log(m * n)) time?\n\nExample 1:\n\n<a href=\"https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/7ca61f56-00d4-4fa0-26cf-56809028ac00/public\" target=\"_blank\">Graphic</a>\n\nInput: matrix = [[1,2,4,8],[10,11,12,13],[14,20,30,40]], target = 10\n\nOutput: true\n\nExample 2:\n\n<a href=\"https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/f25f2085-ce04-4447-9cee-f0a66c32a300/public\" target=\"_blank\">Graphic</a>\n\nInput: matrix = [[1,2,4,8],[10,11,12,13],[14,20,30,40]], target = 15\n\nOutput: false\n\nConstraints:\n\n    m == matrix.length\n    n == matrix[i].length\n    1 <= m, n <= 100\n    -10000 <= matrix[i][j], target <= 10000",
        "code": "class Solution:\n    def search(self, matrix, target):        \n        \"\"\" \n        do a binary search on the rows\n        starting with the middle row,\n        if the target is both less than the start and final value in the row:\n            search the top half of the matrix\n        if the target is both greater than the first and last values in the row:\n            search the bottom half of the matrix\n        otherwise if the value is  in between:\n            go on to do a binary search amid the array normally\n            \n        \"\"\"\n        l, r = 0, len(matrix) - 1\n        while l <= r:\n            m = (l + r) // 2\n            \n            if matrix[m][0] < target and matrix[m][-1] < target:\n                l = m + 1\n            elif matrix[m][0] > target and matrix[m][-1] > target:\n                r = m - 1\n            else:\n                left = 0\n                right = len(matrix[m]) - 1\n                while left <= right:\n                    mid = (left + right) // 2\n                    \n                    if matrix[m][mid] < target:\n                        left = mid + 1\n                    elif matrix[m][mid] > target:\n                        right = mid - 1\n                    else:\n                        print(matrix[m][mid])\n                        return True\n                \n                return False\n        return False\n                   \n# f = Solution().search([[1]], 10)\nf = Solution().search([[1,2,4,8],[10,11,12,13],[14,20,30,40]], 10)\nprint(f)"
    },
    "33": {
        "tag": [
            "875"
        ],
        "title": "Koko Eating Bananas",
        "hint": "try to find the brute force solution first, then remember this is a binary problem",
        "note": "find the K maximum possibility, which will be the maximum value in the list\nK will be between 1 and the maximum so do a binary search on these values\nfigure out how many hours it'll take to eat when K = mid and depending on whether \nthe value is too big or small use the binary search logic to try the next K value",
        "problem": "Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.\n\nKoko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\n\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\n\nReturn the minimum integer k such that she can eat all the bananas within h hours.\n\n \n\nExample 1:\n\nInput: piles = [3,6,7,11], h = 8\nOutput: 4\n\nExample 2:\n\nInput: piles = [30,11,23,4,20], h = 5\nOutput: 30\n\nExample 3:\n\nInput: piles = [30,11,23,4,20], h = 6\nOutput: 23\n\n \n\nConstraints:\n\n    1 <= piles.length <= 104\n    piles.length <= h <= 109\n    1 <= piles[i] <= 109",
        "code": null
    },
    "34": {
        "tag": [
            "153"
        ],
        "title": "Find Minimum in Rotated Sorted Array",
        "hint": null,
        "note": null,
        "problem": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\n\n    [4,5,6,7,0,1,2] if it was rotated 4 times.\n    [0,1,2,4,5,6,7] if it was rotated 7 times.\n\nNotice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\n\nGiven the sorted rotated array nums of unique elements, return the minimum element of this array.\n\nYou must write an algorithm that runs in O(log n) time.\n\n \n\nExample 1:\n\nInput: nums = [3,4,5,1,2]\nOutput: 1\nExplanation: The original array was [1,2,3,4,5] rotated 3 times.\n\nExample 2:\n\nInput: nums = [4,5,6,7,0,1,2]\nOutput: 0\nExplanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\n\nExample 3:\n\nInput: nums = [11,13,15,17]\nOutput: 11\nExplanation: The original array was [11,13,15,17] and it was rotated 4 times. \n\n \n\nConstraints:\n\n    n == nums.length\n    1 <= n <= 5000\n    -5000 <= nums[i] <= 5000\n    All the integers of nums are unique.\n    nums is sorted",
        "code": "class Solution:\n    def findMin(self, nums: List[int]) -> int:\n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            \n            if nums[mid] < nums[right]:\n                right = mid\n            else:\n                left = mid + 1\n                \n        return nums[left]"
    },
    "35": {
        "tag": [
            "33"
        ],
        "title": "Search in Rotated Sorted Array",
        "hint": "focus just on the left side and ask yourself what are the two cases that can exist for the left side and then solve",
        "note": "You know there are two cases that will exist:\n - The left side of the array is organized/ordered\n - The left side of the array is not organized/ordered\n\nif the left side is ordered (the number at the left index is less than the number at the middle index), check regularly:\n - if the target is larger than the middle (which means it is larger than all the numbers on the left side), look on the right side now\n - if the target is less than the left (which means it's number can't be between the left in \n the middle), look on the right side now\notherwise move to the left\n \nif the left side is not ordered (the left side is greater than the middle)\n - check if our target is greater than the left\n - check if our target is less than the middle\nin either of these two cases that means our targets on the left side, if not moved to the right",
        "problem": "You are given an array of length n which was originally sorted in ascending order. It has now been rotated between 1 and n times. For example, the array nums = [1,2,3,4,5,6] might become:\n\n    [3,4,5,6,1,2] if it was rotated 4 times.\n    [1,2,3,4,5,6] if it was rotated 6 times.\n\nGiven the rotated sorted array nums and an integer target, return the index of target within nums, or -1 if it is not present.\n\nYou may assume all elements in the sorted rotated array nums are unique,\n\nA solution that runs in O(n) time is trivial, can you write an algorithm that runs in O(log n) time?\n\nExample 1:\n\nInput: nums = [3,4,5,6,1,2], target = 1\n\nOutput: 4\n\nExample 2:\n\nInput: nums = [3,5,6,0,1,2], target = 4\n\nOutput: -1",
        "code": "def search(self, nums: List[int], target: int) -> int:\n    l, r = 0, len(nums) - 1\n\n    while l <= r:\n        mid = (l + r) // 2\n        if target == nums[mid]:\n            return mid\n\n        if nums[l] <= nums[mid]:\n            if target > nums[mid] or target < nums[l]:\n                l = mid + 1\n            else:\n                r = mid - 1\n                \n        else:\n            if target < nums[mid] or target > nums[r]:\n                r = mid - 1\n            else:\n                l = mid + 1\n    return -1"
    },
    "36": {
        "tag": [
            "4"
        ],
        "title": "Median of Two Sorted Arrays",
        "hint": "the median is the middle number, or average of the middle two numbers, in an array\ntwo pointer",
        "note": null,
        "problem": "You are given two integer arrays nums1 and nums2 of size m and n respectively, where each is sorted in ascending order. Return the median value among all elements of the two arrays.\n\nYour solution must run in O(log(m+n))O(log(m+n)) time.\n\nExample 1:\n\nInput: nums1 = [1,2], nums2 = [3]\n\nOutput: 2.0\n\nExplanation: Among [1, 2, 3] the median is 2.\n\nExample 2:\n\nInput: nums1 = [1,3], nums2 = [2,4]\n\nOutput: 2.5\n\nExplanation: Among [1, 2, 3, 4] the median is (2 + 3) / 2 = 2.5.",
        "code": "# TWO POINTER SOLUTION\nclass Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        len1 = len(nums1)\n        len2 = len(nums2)\n        # no need to look past this point if both arrays were combined\n        len_combined_halved = (len1 + len2) // 2 + 1\n        i1 = 0\n        i2 = 0\n        median1 = 0\n        median2 = 0\n\n        # Find median.\n        for _ in range(0, len_combined_halved):\n            median2 = median1\n            in_arr1_bounds = i1 < len1\n            in_arr2_bounds = i2 < len2\n            in_both_arr_bounds = in_arr1_bounds and in_arr2_bounds\n            \n            if in_both_arr_bounds:\n                if nums1[i1] <= nums2[i2]:\n                    median1 = nums1[i1]\n                    i1 += 1\n                else:\n                    median1 = nums2[i2]\n                    i2 += 1\n            \n            elif in_arr1_bounds:\n                median1 = nums1[i1]\n                i1 += 1\n            \n            elif in_arr2_bounds:\n                median1 = nums2[i2]\n                i2 += 1\n\n        # Check if the sum of len1 and len2 is odd.\n        if (len1 + len2) % 2 == 1:\n            return float(median1)\n        else:\n            ans = float(median1) + float(median2)\n            return ans / 2.0\n\nf = Solution().findMedianSortedArrays([1, 2], [3, 4])\nprint(f)"
    }
}
	}

	export {
		fc_data
	}

	
